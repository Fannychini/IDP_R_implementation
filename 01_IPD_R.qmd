---
title: "IDP implementation in R"
author: "Fanny Franchini"
format: html
editor: source
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)

# Library
library(tidyverse)
library(lubridate)

# Reproducibility
set.seed(239) 
sessionInfo()
```

## Background
SAS code for the implementation of the Individualised Dispensing Patterns (IDP) method for defining medicine exposure is published: *Bharat, C, Degenhardt, L, Pearson, S-A, et al. A data-informed approach using individualised dispensing patterns to estimate medicine exposure periods and dose from pharmaceutical claims data. Pharmacoepidemiol Drug Saf. 2023; 32( 3): 352- 365. doi:10.1002/pds.5567*

SAS code available here <https://github.com/c-bharat/IDP_exposure_method>.

**The objective is to implement the method in R**
1. Understanding the SAS code
2. Implementation of `e_pop_estimate` macro
3. Implementation of `exposure_by_drug` macro

## Undertanding the SAS code
Noting this is based on my understanding of the method as a non-SAS user. 

The `e_pop_estimate` macro calculates population-level exposure based on a drug or medicine group, by:

- sorting dispensing data by person (PPN) and date
- identifying continuous episodes of medicine use (new episode if gap ≥ 365 days)
- calculating 'days per unit' by dividing the gap between dispensings by previous quantity
- calculating the 20th, 50th, 80th and 90th percentiles of this distribution

The `exposure_by_drug` macro creates the exposure history for each individual. It calculates the start and end dates of exposure intervals, based on the dispensing data, and assigns exposure status (current, recent, or formerly exposed). This is done by:

- Taking the drug group number, output dataset name, and study end date
- Applying the IDP method to calculate personalised exposure duration estimates
- Using a  weighted formula that adapts as more dispensing data becomes available, ~ sliding window


The weighted formula creates three exposure categories:

- Currently exposed (es=1): from dispensing day to estimated end of supply
- Recently exposed (es=2): short period after current exposure (default 7 days)
- Formerly exposed (es=3): after recent exposure until next dispensing

```
/* For first dispensing */
IF t_nm1=. THEN e_n = q_D*(P_80);

/* For second dispensing - weighted average */
ELSE IF t_nm2=. THEN e_n = q_D*( (3/6)*(Date_of_Supply-t_nm1)/q_nm1 + (2/6)*(P_80) + (1/6)*(P_80) );

/* For third and later - more personalised */
ELSE IF t_nm3=. THEN e_n = q_D*( (3/6)*(Date_of_Supply-t_nm1)/q_nm1 + (2/6)*(t_nm1-t_nm2)/q_nm2 + (1/6)*(P_80) );
```

The output dataset contains exposure histories with:

- start_date/end_date: interval boundaries
- es: exposure status (1=current, 2=recent, 3=former)
- cens_date: censoring date (death or end of follow-up)
- episode tracking variables

## Implementation of `e_pop_estimate` macro

```{r}
# including necessary steps
# stick to the same variable names
# lots of issues with dates and unexpected behaviours
# decided to make it work prior optimisation of code
e_pop_estimate <- function(item_code, macro_d) {
  
  # sort data by PPN and dispensing date
  medicine_data <- macro_d %>%
    arrange(PPN, Date_of_Supply) %>%
    # keep data for the specific medicine/class
    filter(group == item_code)
  
  # need empty df to collect continuous episodes and new episodes
  e_pope <- data.frame()
  new_episode <- data.frame()
  
  # process data row by row, sticking to SAS code 
  patients <- unique(medicine_data$PPN)
  for (patient in patients) {
    patient_data <- medicine_data %>% filter(PPN == patient)
    # initialise tracking variables
    last_time <- as.Date(NA)
    last_q <- NA
    t_nm1 <- as.Date(NA)
    q_nm1 <- NA
    new_episode_flag <- 0
    
    for (i in 1:nrow(patient_data)) {
      # update tracking variables
      t_nm1 <- last_time
      q_nm1 <- last_q
      last_q <- patient_data$q_D[i]
      last_time <- as.Date(patient_data$Date_of_Supply[i])
      
      # check if new episode (first dispensing or gap ≥ 365 days)
      if (is.na(t_nm1) || (patient_data$Date_of_Supply[i] - t_nm1) >= 365) {
        new_episode_flag <- 1
        # add row to new_episode dataset
        row <- patient_data[i, ]
        row$last_time <- last_time
        row$last_q <- last_q
        row$t_nm1 <- t_nm1
        row$q_nm1 <- q_nm1
        row$new_episode <- new_episode_flag
        
        new_episode <- rbind(new_episode, row)
        # reset flag
        new_episode_flag <- 0} 
      
      else {
        # add row to e_pope dataset (continuous episode)
        row <- patient_data[i, ]
        row$last_time <- last_time
        row$last_q <- last_q
        row$t_nm1 <- t_nm1
        row$q_nm1 <- q_nm1
        row$new_episode <- new_episode_flag
        
        e_pope <- rbind(e_pope, row)
      }
    }
  }
  
  # checks with first 50 rows of each dataset
  if (nrow(e_pope) > 0) {
    print("First 50 rows of e_pope:")
    print(head(e_pope, 50))}
  
  if (nrow(new_episode) > 0) {
    print("First 50 rows of new_episode:")
    print(head(new_episode, 50))}
  
  # calculate days per unit following a dispensing day
  if (nrow(e_pope) > 0) {
    e_pop_est <- e_pope %>%
      mutate(dif = as.numeric(Date_of_Supply - t_nm1),
             e_pop_est = dif / q_nm1) %>%
      group_by(PPN) %>%
      mutate(first_interval = row_number() == 1) %>%
      ungroup()
    
    # checks
    print("first 50 rows of e_pop_est:")
    print(head(e_pop_est, 50))
    
    # calculate percentiles (20th 50th 80th 90th)
    percentiles <- e_pop_est %>%
      summarise(N = n(),
                P_20 = quantile(e_pop_est, 0.20, na.rm = TRUE),
                P_50 = quantile(e_pop_est, 0.50, na.rm = TRUE),
                P_80 = quantile(e_pop_est, 0.80, na.rm = TRUE),
                P_90 = quantile(e_pop_est, 0.90, na.rm = TRUE)) 
    percentiles$item_code <- item_code # add parameter value
    
    # checks
    print("percentile:")
    print(percentiles)
    
    return(percentiles)
  } 
  
  else {
    warning("no continuous episodes found for this item_code")
    
    return(data.frame(N = 0, P_20 = NA, P_50 = NA,
                      P_80 = NA, P_90 = NA, item_code = item_code))
  }
}
```

## Implementation of `exposure_by_drug` macro
This needs entire reworking

```{r}
# including necessary steps
exposure_by_drug <- function(drug_number, macro_d, EndDate, output) {
  # subset dispensing data for the specific drug
  macro_d_temp <- macro_d %>%
    filter(group == drug_number & Date_of_Supply >= Date_of_Supply_index)
  
  # checks
  print(head(macro_d_temp, 5))
  
  # merge population-level exposure estimate
  e_est_macro <- combined_item_code3 %>%
    filter(group == drug_number) %>%
    select(group, P_80)
  
  macro_d_temp <- merge(macro_d_temp, e_est_macro, by = "all")
  
  # evaluation of exposure duration
  macro_d1 <- macro_d_temp %>%
    mutate(recent_exp = 7, # max length of recent exposure period
           # for the 1st observation, set all parameters to zero/missing
           ep_num = 0,
           episode_dispensing = 0,
           t_nm1 = NA,
           t_nm2 = NA,
           t_nm3 = NA,
           q_nm1 = NA,
           q_nm2 = NA,
           q_nm3 = NA,
           e_n = 99999999, # as per SAS code
           first_date = Date_of_Supply,
           unique_ep_id = NA) %>%
    group_by(PPN) %>%
    mutate(t_nm1 = ifelse(episode_dispensing >= 1, last_time, NA),
           q_nm1 = ifelse(episode_dispensing >= 1, last_q, NA)) %>%
    ungroup()
  
  # calculate exposure number and assign exposure periods
  macro_d1 <- macro_d1 %>%
    mutate(e_n = q_D * P_80)
  
  # need to create episode data and apply exposure calculation logic
  macro_d2 <- macro_d1 %>%
    arrange(PPN, desc(Date_of_Supply)) %>%
    mutate(PPN1 = lag(PPN),
           SEE1 = lag(Date_of_Supply),
           EP1 = lag(ep_num)) %>%
    group_by(PPN) %>%
    mutate(SEE1 = ifelse(first(PPN), '31DEC9999', SEE1), # as per SAS code
           last = ifelse(first(PPN), 1, last)) %>%
    ungroup()        
  
  # generate exposure intervals (current / recent / formerly exposed)
  macro_episodes <- macro_d2 %>%
    mutate(es = 1, # = currently exposed
           start_date = Date_of_Supply - 1,
           end_date = pmin(Date_of_Supply + e_n - 1, SEE1 - 1, DeathDate, EndDate),
           cens_date = ifelse(!is.na(DeathDate), DeathDate, EndDate))
  
  # checks
  print(head(macro_episodes, 50))
  
  # generate final dataframe
  output_data <- macro_episodes %>%
    select(PPN, start_date, end_date, es, cens_date)
  
  return(output_data)
}
```


## Testing

### Generate fake data
```{r}
create_test_data <- function() {
  test_data <- data.frame(
    PPN = rep(c(1001, 1002, 1003, 1004), times = c(5, 3, 6, 4)),
    group = rep(c(101, 101, 101, 102), times = c(5, 3, 6, 4)),
    Date_of_Supply = as.Date(c("2020-01-15", "2020-02-15", "2020-03-15", "2020-04-15", "2020-05-15",
                               "2020-01-10", "2020-02-10", "2021-03-20",
                               "2020-01-05", "2020-02-10", "2020-04-20", "2020-07-01", "2020-08-15", "2021-09-20",
                               "2020-01-15", "2020-03-15", "2020-06-15", "2020-09-15")),
    q_D = c(30, 30, 30, 30, 30, # PPN 1001
            28, 28, 28, # PPN 1002
            14, 28, 30, 60, 30, 30, # PPN 1003
            60, 60, 60, 60), # PPN 1004
    Date_of_Supply_index = as.Date(c(rep("2020-01-01", 5), rep("2020-01-01", 3),
                                     rep("2020-01-01", 6), rep("2020-01-01", 4))),
    DeathDate = as.Date(c(rep(NA, 5), rep(NA, 2), "2021-06-30", # PPN 1002 deceased status
                          rep(NA, 6), rep(NA, 4))))
  
  return(test_data)
}
```

### Test implementation `e_pop_estimate`
```{r}
test_e_pop_estimate <- function() {
  cat("\ne_pop_estimate testing\n")
  # generate test data
  test_data <- create_test_data()
  
  # run the function for group 101 and 102
  percentiles_101 <- e_pop_estimate(101, test_data)
  percentiles_102 <- e_pop_estimate(102, test_data)
  
  # show results
  cat("\npercentiles for group 101:\n")
  print(percentiles_101)
  cat("\npercentiles for group 102:\n")
  print(percentiles_102)
  
  # combine data
  combined_item_code <- rbind(percentiles_101, percentiles_102)
  combined_item_code3 <- combined_item_code %>%
    mutate(group = as.numeric(item_code))
  
  cat("\ncombined percentiles:\n")
  print(combined_item_code3)
  
  return(combined_item_code3)
}
```

### Test implementation `exposure_by_drug`
```{r}
# to write up but suspect current implementation is bad
```

